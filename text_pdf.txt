if that compares the value of i + sep.size() with e . We can access the first such character as i[sep.size()] , which is an abbreviation for *(i + sep.size()) . We test whether that character can appear in a URL by passing the character to not_url_char . This function returns true if the character is not valid, so we negate the return to check whether the character is valid. If the separator is not part of a URL, then the function advances i past the separator and keeps looking. This code uses the decrement operator , which we mentioned in the operator table in §2.7/32, but which we have not previously used. It works like the increment operator, but it decrements its operand instead. As with the increment operator, it comes in prefix and postfix versions. The prefix version, which we use here, decrements its operand and returns the new value. 6.2 Comparing grading schemes In §4.2/61, we presented a grading scheme that based students' final grades, in part, on their median homework scores. Devious students can exploit this scheme by deliberately not turning in all their homework assignments. After all, the bottom half of their homework grades has no effect on their final grade. If they've done enough homework to ensure a good grade, why not stop doing homework altogether? In our experience, most students do not exploit this particular loophole. However, we did have occasion to teach one class that gleefully and openly did so. We wondered whether the students who skipped homework had, on average, different final grades than those who did all the homework. While we were thinking about how to answer that question, we decided that it might be interesting to see what the answer would be if we used one of two alternative grading schemes: Using the average instead of the median, and treating those assignments that the student failed to turn in as zero Using the median of only the assignments that the student actually submitted For each of these grading schemes, we wanted to compare the median grade of the students who turned in all their homework with the median grade of the students who missed one or more assignments. We wound up with a program that had to solve two distinct subproblems: 1. 2. Read all the student records, separating the students who did all the homework from the others. Apply each of the grading schemes to all the students in each group, and report the median grade of each group. 6.2.1 Working with student records Our first subproblem is to read and classify the student records. Fortunately, we already have some code we can use in solving this part of the problem: We can use the Student_info type from §4.2.1/61 and the associated read function from §4.2.2/62 to read the student data records. What we don't have yet is a function that checks whether a student has done all the homework. Writing such a function is easy: bool did_all_hw(const Student_info& s) { return ((find(s.homework.begin(), s.homework.end(), 0)) == s.homework.end()); } This function looks in s.homework to see whether any of the values stored there is 0. Because we give at least partial credit for any assignment that is turned in, a 0 grade means that the assignment was not submitted. We compare the return from find with homework.end(). As usual, find returns its second argument if it fails to find the value that it seeks. With these two functions, writing code to read and separate the student records is simplicity itself. We'll read each student record, check whether the student did all the homework, and append the record to one of two vector s, which, for want of a better idea, we'll name did and didnt . While we're at it, we'll check that neither vector is empty, so that we'll know that our analysis will actually tell us something useful: vector<Student_info> did, didnt; Student_info student; // read all the records, separating them based on whether all homework was done while (read(cin, student)) { if (did_all_hw(student)) did.push_back(student); else didnt.push_back(student); } // check that both groups contain data if (did.empty()) { cout << "No student did all the homework!" << endl; return 1; } if (didnt.empty()) { cout << "Every student did all the homework!" << endl; return 1; } The only new idea here is the empty member function, which yields true if the container is empty and false otherwise. It is a better idea to use this function to check for an empty container than it is to compare the size with 0, because for some kinds of containers, it might be more efficient to check whether the container has any elements than to figure out exactly how many elements there are. 6.2.2 Analyzing the grades We now know how to read and classify student records into the did and didnt vectors. The next step is to analyze them, which means we need to think a little about how to structure the analysis. We know that we have three analyses to perform, and each analysis has two parts, which analyze separately the students who did and who didn't do all the homework. Because we will do each analysis on two sets of data, we certainly want to make each analysis its own function. However, there are some operations, such as reporting in a common format, that we are going to want to do on pairs of analyses, rather than on individual analyses. Evidently, we'll want to make writing the results of each pair of analyses into a function as well. The tricky part is that we want to call the function that writes the analysis results three times, once for each kind of analysis. We want that function to call the appropriate analysis function twice, once each for the did and didnt objects. However, we want the function that generates the reports to call a different analysis function each time we call it! How do we arrange that? The easiest solution is to define three analysis functions and pass each one as an argument to the reporting function. Remember that we've used such arguments already, such as when we passed the compare function to the library sort routine in §4.2.2/64. In this case, we want our output routine to take five arguments: The stream on which to write the output A string that represents the name of the analysis The function to use for the analysis Two arguments, each of which is one of the vector s that we want to analyze For example, let's assume that the first analysis, which looks at the medians, is done by a function called median_analysis . Then, we'd like to report the results for each group of students by executing write_analysis(cout, "median", median_analysis, did, didnt); Before we define write_analysis , let's define median_analysis . We would like to give that function a vector of student records, and we would like it to compute the students' grades according to the normal grading scheme and to return the median of those grades. We can define that function as follows: // this function doesn't quite work double median_analysis(const vector<Student_info>& students) { vector<double> grades; transform(students.begin(), students.end(), back_inserter(grades), grade); return median(grades); } Although this function might appear difficult at first glance, it introduces only one new idea, namely the transform function. This function takes three iterators and a function. The first two iterators specify a range of elements to transform; the third iterator is the destination into which to put the result of running the function. When we call transform , we are responsible for ensuring that the destination has room for the values from the input sequence. In this case, there is no problem, because we obtain the destination by calling back_inserter (§6.1/102), thereby arranging that transform 's results will be appended to grades , which will automatically grow as necessary to accommodate the results. The fourth argument to transform is a function that transform applies to each element of the input sequence to obtain the corresponding element of the output sequence. Therefore, when we call transform in this example, the effect is to apply the grade function to each element of students , and to append each grade to the vector named grades . When we have all these students' grades, we call median , which we defined in §4.1.1/53, to compute their median. There's only one problem: As the comment notes, this function doesn't quite work. One reason that it doesn't work is that there are several overloaded versions of the grade function. The compiler doesn't know which version to call, because we haven't given grade any arguments. We know that we want to call the version from §4.2.2/63, but we need a way to tell the compiler to do so. The other reason is that the grade function will throw an exception if any student did no homework at all, and the transform function does nothing about exceptions. If an exception occurs, the transform function will be stopped at the point of the exception, and control will return to median_analysis . Because median_analysis doesn't handle the exception either, the exception will continue to propagate outward. The effect will be that this function will also exit prematurely, passing control to its caller, and so on, until control reaches an appropriate catch . If there is no such catch , as would be likely in this case, the program itself is terminated, and the message that was thrown is printed (or not, depending on the implementation). We can solve both problems by writing an auxiliary function that will try the grade function and handle the exception. Because we are calling the grade function explicitly, rather than passing it as an argument, the compiler will be able to figure out which version we mean: double grade_aux(const Student_info& s) { try { return grade(s); } catch (domain_error) { return grade(s.midterm, s.final, 0) ; } } This function will call the version of grade from §4.2.2/63. If an exception occurs, we will catch it and call the version of grade , from §4.1/52, that takes three double s that represent the exam scores and overall homework grade. Thus, we'll assume that students who did no homework at all got a 0 grade on their homework, but their exams still count. Now, we can rewrite the analysis function to use grade_aux : // this version works fine double median_analysis(const vector<Student_info>& students) { vector<double> grades; transform(students.begin(), students.end(), back_inserter(grades), grade_aux); return median(grades); } Having seen what an analysis routine looks like, we are now in a position to define write_analysis , which uses an analysis routine to compare two sets of students: void write_analysis(ostream& out, const string& name, double analysis(const vector<Student_info>&), const vector<Student_info>& did, const vector<Student_info>& didnt) { out << name << ": median(did) = " << analysis(did) << ", median(didnt) = " << analysis(didnt) << endl; } Again, this function is surprisingly small, although it does introduce two new ideas. The first is how to define a parameter that represents a function. The parameter definition for analysis looks just like the function declaration that we wrote in §4.3/67. (Actually, as we shall learn in §10.1.2/172, there is slightly more going on here than meets the eye. The additional detail doesn't affect the current discussion directly.) The other new idea is the return type, void. The built-in type void can be used only in a few restricted ways, one of which is to name a return type. When we say a function "returns" a void , we're really saying that it has no return value. We can exit from such a function by executing a return statement with no value, such as return; or, as we do here, by falling off the end of the function. Ordinarily, we cannot just fall off the end of a function, but the language allows functions that return void to do so. At this point, we can write the rest of our program: int main() { // students who did and didn't do all their homework vector<Student_info> did, didnt; // read the student records and partition them Student_info student; while (read(cin, student)) { if (did_all_hw(student)) did.push_back(student); else didnt.push_back(student); } // verify that the analyses will show us something if (did.empty()) { cout << "No student did all the homework!" << endl; return 1; } if (didnt.empty()) { cout << "Every student did all the homework!" << endl; return 1; } // do the analyses write_analysis(cout, "median", median_analysis, did, didnt); write_analysis(cout, "average", average_analysis, did, didnt); write_analysis(cout, "median of homework turned in", optimistic_median_analysis, did, didnt); return 0; } All that remains is to write average_analysis and optimistic_median_analysis . 6.2.3 Grading based on average homework grade We would like the average_analysis function to compute the students' grades by using the average homework grade, rather than the median. Therefore, the logical first step is to write a function to compute the average of a vector , with the aim of using it instead of median for grade computation: double average(const vector<double>& v) { return accumulate(v.begin(), v.end(), 0.0) / v.size(); } This function uses accumulate , which, unlike the other library algorithms we've used, is declared in <numeric> . As this header's name implies, it offers tools for numeric computation. The accumulate function adds the values in the range denoted by its first two arguments, starting the summation with the value given by its third argument. The type of the sum is the type of the third argument, so it is crucially important for us to use 0.0 , as we did here, instead of 0. Otherwise, the result would be an int , and any fractional part would be lost. Having used accumulate to generate the sum of all the elements in the range, we divide that sum by v.size() , which is the number of elements in the range. The result of that division, of course, is the average, which we return to our caller. Once we have the average function, we can use it to implement the average_grade function to reflect this alternative grading policy: double average_grade(const Student_info& s) { return grade(s.midterm, s.final, average(s.homework)); } This function uses the average function to compute an overall homework grade, which it then gives to the grade function from §4.1/52 to use in computing the final grade. With this infrastructure in place, the average_analysis function is simplicity itself: double average_analysis(const vector<Student_info>& students) { vector<double> grades; transform(students.begin(), students.end(), back_inserter(grades), average_grade); return median(grades); } The only difference between this function and median_analysis (§6.2.2/113) is its name and its use of average_grade instead of grade_aux . 6.2.4 Median of the completed homework The last analysis scheme, optimistic_median_analysis , gets its name from the optimistic assumption that the students' grades on the homework that they didn't turn in would have been the same as the homework that they did turn in. With that assumption, we would like to compute the median of just the homework that each student submitted. We'll call this computation an optimistic median, and we'll begin by writing a function to compute it. Of course, we have to contend with the possibility that a student did no homework at all, in which case we'll use 0 as the overall homework grade: // median of the nonzero elements of s.homework, or 0 if no such elements exist double optimistic_median(const Student_info& s) { vector<double> nonzero; remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0); if (nonzero.empty()) return grade(s.midterm, s.final, 0); else return grade(s.midterm, s.final, median(nonzero)); } This function works by extracting the nonzero elements from the homework vector and putting them into a new vector, called nonzero . Once we have the nonzero homework grades, we call the version of grade defined in §4.1/52 to compute the final score based on the median of the homework assignments that were actually submitted. The only new idea in this function is how we get values into nonzero , which we do by calling the remove_copy algorithm. To understand the call to remove_copy , you may find it useful to know that the library provides "copying" versions of many of the algorithms. So, for example, remove_copy does what remove does, but copies its results to an indicated destination. The remove function finds all values that match a given value and "removes" those values from the container. All the values in the input sequence that are not "removed" will be copied into the destination. We'll have more to say shortly about what "remove" means in this context. The remove_copy function takes three iterators and a value. As with most algorithms, the first two iterators denote the input sequence. The third denotes the beginning of the destination for the copy. As with copy , the remove_copy algorithm assumes that there is enough space in the destination to hold all the elements that are copied. We call back_inserter to grow nonzero as needed. We should now be able to see that the effect of the remove_copy call is to copy into nonzero all the nonzero elements in s.homework . We then check whether v is empty, and if not, we do the normal grade calculation based on the median of the nonzero grades. If v is empty, then we use 0 as the homework grade. Of course, to complete our analysis, we need to write an analysis function to call our optimistic_median function. We leave doing so as an exercise. 6.3 Classifying students, revisited In Chapter 5, we looked at the problem of copying records with failing grades into a separate vector and then removing those records from the existing vector. The obvious, easy approach to this problem proved to have abysmal performance as the input size grew. We went on to show how to solve the performance problem by using a list instead of a vector, but we also promised to revisit the problem and show an algorithmic solution that would perform similarly to the revised data structure. We can use the algorithm library to demonstrate two other solutions. The first is slightly slower because it uses a pair of library algorithms and visits every element twice. We can do better by using a more specialized library algorithm that will let us solve the problem in a single pass. 6.3.1 A two-pass solution Our first approach will use a strategy similar to the one that we used in §6.2.4/115, when we wanted only the nonzero homework grades. In that case, we didn't want to change homework itself, so we used remove_copy to put copies of the nonzero homework grades into a separate vector. In our current problem, we need both to copy and remove the nonzero elements: vector<Student_info> extract_fails(vector<Student_info>& students) { vector<Student_info> fail; remove_copy_if(students.begin(), students.end(), back_inserter(fail), pgrade); students.erase(remove_if(students.begin()), students.end(), fgrade), students.end()); return fail; } The interface to the program is identical to that from §5.3/82, which presented the obvious vector-based solution that used iterators instead of indices. As in that solution, we'll use the vector that we were passed to hold grades for students who passed, and define fail to hold the failing grades. There the similarities end. In the original program, we used an iterator named iter to march through the container, copying the records with failing grades into fail, and using the erase member to erase them from students. This time, we use the remove_copy_if function to copy the failing grades into fail. That function operates as did the remove_copy function that we used in §6.2.4/116, except that it uses a predicate as its test, rather than a value. We give it a predicate that inverts the result of calling fgrade (§5.1/75): bool pgrade(const Student_info& s) { return !fgrade(s); } When we pass a predicate to remove_copy_if, we are asking it "remove" each element that satisfies the predicate. In this context, "removing" an element means not copying it, so we copy only those elements that do not satisfy the predicate. Therefore, passing pgrade to remove_copy_if copies only the student records with failing grades. The next statement is somewhat complicated. First, we call remove_if to "remove" the elements that correspond to failing grades. Again, the quotes around "remove" are because nothing is actually removed. Instead, remove_if copies all the elements that do not satisfy the predicate—in this case, all the student records with passing grades. This call is tricky to understand because remove_if uses the same sequence as its source and destination. What it really does is copy to the beginning of the sequence the elements that don't meet the predicate. For example, suppose we started with seven students with grades as follows: Then the call to remove_if would leave the first two records untouched, because they're already in the right places. It would "remove" the next two records by treating them as free space to be overwritten by the next records that should be kept. So, when it sees the fifth record, which represents a student who passed, it would copy that record into the now free position that used to hold the first of the "removed" failing records, and so on: The result in this case would be to copy the four passing records to the beginning of the sequence, leaving the remaining three records untouched. So that we can know how much of the sequence is still relevant, remove_if returns an iterator that refers to one past the last element that it did not "remove": Next, we need to erase these unneeded records from students. We have not used this version of erase before. It takes two iterators, and erases all the elements in the range delimited by those iterators. If we erase the elements between the iterator returned from the call to remove_if and students.end(), we are left with just the passing records: 6.3.2 A single-pass solution Our first algorithmic solution performs pretty well, but we should be able to do slightly better. The reason is that the solution in §6.3.1/117 calculates the grade for every element in students twice: once from remove_copy_if and a second time from remove_if. Although there is no library algorithm that does exactly what we want, there is one that approaches our problem from a different angle: It takes a sequence and rearranges its elements so that the ones that satisfy a predicate precede the ones that do not satisfy it. There are really two versions of this algorithm, which are named partition and stable_partition. The difference is that partition might rearrange the elements within each category, and stable_partition keeps them in the same order aside from the partitioning. So, for example, if the student names were already in alphabetical order, and we wanted to keep them that way within each category, we would need to use stable_partition rather than partition. Each of these algorithms returns an iterator that represents the first element of the second section. Therefore, we can extract the failing grades this way: vector<Student_info> extract_fails(vector<Student_info>& students) { vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), pgrade); vector<Student_info> fail(iter, students.end()); students.erase(iter, students.end()); return fail; } To understand what is going on here, let's start with our hypothetical input data again: After calling stable_partition, we would have We construct fail from a copy of the failing records, which are the ones in the range [iter, students.end())., and then erase those elements from students. When we ran our algorithm-based solutions, they had roughly the same overall performance as the list-based solution. As expected, once the input was large enough, the algorithm and list-based solutions were substantially better than the vector solution that used erase. The two algorithmic solutions are good enough that the time consumed by the input library dominated the timings for input files up to about 75,000 records. To compare the effects of the two strategies in extract_fails, we separately analyzed the performance of just this portion of the program. Our timings confirmed that the one-pass algorithm ran about twice as fast as the two-pass solution. 6.4 Algorithms, containers, and iterators There is a fact that is crucial to understand in using algorithms, iterators, and containers: Algorithms act on container elements—they do not act on containers. The sort, remove_if, and partition functions all move elements to new positions in the underlying container, but they do not change the properties of the container itself. For example, remove_if does not change the size of the container on which it operates; it merely copies elements around within the container. This distinction is especially important in understanding how algorithms interact with the containers that they use for output. Let's look in more detail at our use of remove_if in §6.3.1/117. As we've seen, the call remove_if(students.begin(), students.end(), fgrade) did not change the size of students. Rather, it copied each element for which the predicate was false to the beginning of students, and left the rest of the elements alone. When we need to shorten the vector to discard those elements, we must do so ourselves. In our example, we said students.erase(remove_if(students.begin(), students.end(), fgrade), students.end()); Here, erase changes the vector by removing the sequence indicated by its arguments. This call to erase shortens students so that it contains only the elements we want. Note that erase must be a member of vector, because it acts directly on the container, not just on its elements. Similarly, it is important to be aware of the interaction between iterators and algorithms, and between iterators and container operations. We've already seen, in §5.3/83 and §5.5.1/86, that container operations such as erase and insert invalidate the iterator for the element erased. More important, in the case of vectors and strings, operations such as erase or insert also invalidate any iterator denoting elements after the one erased or inserted. Because these operations can invalidate iterators, we must be careful about saving iterator values if we are using these operations. Similarly, functions such as partition or remove_if, which can move elements around within the container, will change which element is denoted by particular iterators. After running one of these functions, we cannot rely on an iterator continuing to denote a specific element. 6.5 Details Type modifiers: static type variable; For local declarations, declares variable with static storage class. The value of variable persists across executions of this scope and is guaranteed to be initialized before the variable is used for the first time. When the program exits from the scope, the variable keeps its value until the next time the program enters that scope. We'll see in §13.4/244 that the meaning of static varies with context. Types: The built-in type void can be used in a restricted number of ways, one of which is to indicate that a function yields no return value. Such functions can be exited through a return; that has no value or by falling off the end of the function. Iterator adaptors are functions that yield iterators. The most common are the adaptors that generate insert_iterators, which are iterators that grow the associated container dynamically. Such iterators can be used safely as the destination of a copying algorithm. They are defined in header <iterator>: Yields an iterator on the container c that appends elements to c. The container must support push_back, which the list, vector, and the string types all do. back_inserter(c) front_inserter(c) Like back_inserter, but inserts at the front of the container. The container must support push_front, which list does, but string and vector do not. inserter(c, it) Like back_inserter, but inserts elements before the iterator it. Algorithms: Unless otherwise indicated, <algorithm> defines these algorithms: accumulate(b, e, t) Creates a local variable and initializes it to a copy of t (with the same type as t, which means that the type of t is crucially important to the behavior of accumulate), adds each element in the range [b, e) to the variable, and returns a copy of the variable as its result. Defined in <numeric>. find(b, e, t) find_if(b, e, p) search(b, e, b2, e2) Algorithms to look for a given value in the sequence [b, e). The find algorithm looks for the value t; the find_if algorithm tests each element against the predicate p; the search algorithm looks for the sequence denoted by [b2, e2). copy(b, e, d) remove_copy(b, e, d, t) remove_copy_if(b, e, d, p) Algorithms to copy the sequence from [b, e) to the destination denoted by d. The copy algorithm copies the entire sequence; remove_copy copies all elements not equal to t; and remove_copy_if copies all elements for which the predicate p fails. remove_if(b, e, p) Arranges the container so that the elements in the range [b, e) for which the predicate p is false are at the front of the range. Returns an iterator denoting one past the range of these "unremoved" elements. Like remove_if, but tests which elements to keep against the value t. remove(b, e, t) transform(b, e, d, f) Runs the function f on the elements in the range [b, e), storing the result of f in d. partition(b, e, p) stable_partition(b, e, p) Partitions the elements in the range [b, e), based on the predicate p, so that elements for which the predicate is true are at the front of the container. Returns an iterator to the first element for which the predicate is false, or e if the predicate is true for all elements. The stable_partition function maintains the input order among the elements in each partition. Exercises 6-0. Compile, execute, and test the programs in this chapter. 6-1. Reimplement the frame and hcat operations from §5.8.1/93 and §5.8.3/94 to use iterators. 6-2. Write a program to test the find_urls function. 6-3. What does this program fragment do? vector<int> u(10, 100); vector<int> v; copy(u.begin(), u.end(), v.begin()); Write a program that contains this fragment, and compile and execute it. 6-4. Correct the program you wrote in the previous exercise to copy from u into v. There are at least two possible ways to correct the program. Implement both, and describe the relative advantages and disadvantages of each approach. 6-5. Write an analysis function to call optimistic_median. 6-6. Note that the function from the previous exercise and the functions from §6.2.2/113 and §6.2.3/115 do the same task. Merge these three analysis functions into a single function. 6-7. The portion of the grading analysis program from §6.2.1/110 that read and classified student records depending on whether they did (or did not) do all the homework is similar to the problem we solved in extract_fails. Write a function to handle this subproblem. 6-8. Write a single function that can be used to classify students based on criteria of your choice. Test this function by using it in place of the extract_fails program, and use it in the program to analyze student grades. 6-9. Use a library algorithm to concatenate all the elements of a vector<string>. 7 Using associative containers All the containers that we have used until now have been sequential containers, whose elements remain in the sequence that we choose for them. When we use push_back or insert to add elements to a sequential container, each element will stay where we put it until we do something to the container that reorders the elements. Some kinds of programs are hard to write efficiently if we restrict ourselves to sequential containers. For example, if we have a container of integers, and we wish to write a program that determines whether any element of the container has the value 42, we have two plausible strategies—neither of which is ideal. One alternative is to inspect every element of the container until we find 42 or run out of elements. This approach is straightforward, but potentially slow—especially if the container has many elements. The other alternative is for us to keep the container in an appropriate order and devise an efficient algorithm to find the element we seek. This approach can yield fast searches, but such algorithms are not easy to devise. In other words, we must live with a slow program, or come up with our own sophisticated algorithm. Fortunately, as we'll see in this chapter, the library offers a third alternative. 7.1 Containers that support efficient look-up Instead of storing data in a sequential container, we can use an associative container. Such containers automatically arrange their elements into a sequence that depends on the values of the elements themselves, rather than the sequence in which we inserted them. Moreover, associative containers exploit this ordering to let us locate particular elements much more quickly than do the sequential containers, without our having to keep the container ordered by ourselves. Associative containers offer efficient ways to find an element that contains a particular value, and might contain additional information as well. The part of each container element that we can use for these efficient searches is called a key. For example, if we were keeping track of information about students, we might use the student's name as the key, so that we could find students efficiently by name. In the sequential containers, the closest that we have seen to a key is the integer index that accompanies every element of a vector. However, even these indices are not really keys, because every time we insert or delete a vector element, we implicitly change the index of every element after the one that we touched. The most common kind of associative data structure is one that stores key-value pairs, associating a value with each key, and that lets us insert and retrieve elements quickly based on their keys. When we put a particular key-value pair into the data structure, that key will continue to be associated with the same value until we delete the pair. Such a data structure is called an associative array. Many languages, such as AWK, Perl, and Sno-bol, have associative arrays built in. In C++, associative arrays are part of the library. The most common kind of associative array in C++ is called a map, and, analogous with other containers, it is defined in the <map> header. In many ways, maps behave like vectors. One fundamental difference is that the index of a map need not be an integer; it can be a string, or any other type with values that we can compare so as to keep them ordered. Another important difference between associative and sequential containers is that, because associative containers are self-ordering, our own programs must not do anything that changes the order of the elements. For that reason, algorithms that change the contents of containers often don't work for associative containers. In exchange for that restriction, associative containers offer a variety of useful operations that are impossible to implement efficiently for sequential containers. This chapter presents several programming examples that use maps to write compact and efficient look-up-intensive programs. 7.2 Counting words As a simple example, think about how we might count the number of times that each distinct word occurs in our input. With associative arrays, the solution is almost trivial: int main() { string s; map<string, int> counters; // store each word and an associated counter // read the input, keeping track of each word and how often we see it while (cin >> s) ++counters[s]; // write the words and associated counts for (map<string, int>::const_iterator it = counters.begin(); it != counters.end(); ++it) { cout << it->first << "\t" << it->second << endl; } return 0; } As with other containers, we must specify the type of the objects that the map will hold. Because a map holds key-value pairs, we need to mention not only the type of the values, but also the type of the keys. So, map<string, int> counters; defines counters as a map that holds values of type int that are associated with keys of type string. We often speak of such a container as "a map from string to int," because we can use the map by giving it a string as a key, and getting back the associated int data. The way we define counters captures our intent to associate each word that we read with an integer counter that records how many times we have seen that word. The input loop reads the standard input, a word at a time, into s. The interesting part is ++counters[s]; What happens here is that we look in counters, using the word that we just read as the key. The result of counters[s] is the integer that is associated with the string stored in s. We then use ++ to increment that integer, which indicates that we have seen the word once more. What happens when we encounter a word for the first time? In that case, counters will not yet contain an element with that key. When we index a map with a key that has not yet been seen, the map automatically creates a new element with that key. That element is value- initialized, which, for simple types such as int, is equivalent to setting the value to zero. Thus, when we read a new word for the first time and execute ++counters[s] with that new word, we are guaranteed that the value of counters[s] will be zero before we increment it. Incrementing counters[s] will, therefore, correctly indicate that we have seen that word once so far. Once we have read the entire input, we must write the counters and the associated words. We do so in much the same way as we would write the contents of a list or a vector: We iterate through the container in a for loop, which uses a variable of the iterator type defined by the map class. The only real difference is in how we write the data in the body of the for statement: cout << it->first << "\t" << it->second << endl; Recall that an associative array stores a collection of key-value pairs. Using [] to access a map element conceals this fact, because we put the key inside the [] and get back the associated value. So, for example, counters[s] is an int. However, when we iterate over a map, we must have a way to get at both the key and the associated value. The map container lets us do so by using a companion library type called pair. A pair is a simple data structure that holds two elements, which are named first and second. Each element in a map is really a pair, with a first member that contains the key and a second member that contains the associated value. When we dereference a map iterator, we obtain a value that is of the pair type associated with the map. The pair class can hold values of various types, so when we create a pair, we say what the types of the first and second data members should be. For a map that has a key of type K and a value of type V, the associated pair type is pair<const K, V>. Note that the pair associated with a map has a key type that is const. Because the pair key is const, we are prevented from changing the value of an element's key. If the key were not const, we might implicitly change the element's position within the map. Accordingly, the key is always const, so that if we dereference a map<string, int> iterator, we get a pair<const string, int>. Thus, it->first is the current element's key, and it->second is the associated value. Because it is an iterator, *it is an lvalue (§4.1.3/56), and therefore it->first and it->second are also lvalues. However, the type of it->first includes const, which prevents us from changing it. With this knowledge, we can see that the output statement writes each key (that is, each distinct word from the input), followed by a tab and the corresponding count. 7.3 Generating a cross-reference table Once we know how to count how often words occur in the input, a logical next step is to write a program to generate a cross-reference table that indicates where each word occurs in the input. This extension requires several changes to our basic program. First, instead of reading a word at a time, we'll need to read a line at a time, so that we can associate line numbers with words. Once we're reading lines instead of words, we'll need a way to break each line into its constituent words. Fortunately, we already wrote such a function, named split, in §6.1.1/103. We can use this function to turn each input line into a vector<string>, from which we can extract each word. Rather than using split directly, we're going to make it a parameter to the cross-reference function. That way, we leave open the possibility of changing the way we find the words on a line. For example, we could pass the find_urls function from §6.1.3/105, and use the cross-reference function to see where URLs appear in the input. As before, we will use a map with keys that are the distinct words from the input. This time, however, we will have to associate a more complicated value with each key. Instead of keeping track of how often the word occurs, we want to know all the line numbers on which the word occurred. Because any given word may occur on many lines, we will need to store the line numbers in a container. When we get a new line number, all we will need to do is append that number to those that we already have for that word. Sequential access to the container elements will suffice, so we can use a vector to keep track of line numbers. Therefore, we will need a map from string to vector<int>. With these preliminaries out of the way, let's look at the code: // find all the lines that refer to each word in the input map<string, vector<int> > xref(istream& in, vector<string> find_words(const string&) = split) { string line; int line_number = 0; map<string, vector<int> > ret; // read the next line while (getline(in, line)) { ++line_number; // break the input line into words vector<string> words = find_words(line); // remember that each word occurs on the current line for (vector<string>::const_iterator it = words.begin(); it != words.end(); ++it) ret[*it].push_back(line_number); } return ret; } Both the return type and the argument list of this function deserve attention. If you look at the declaration of our return type and the local variable ret, you will see that we carefully wrote >> instead of >>. The compiler needs that space, because if it sees >> without intervening spaces, it will assume that it is looking at an >> operator, rather than at two separate > symbols. In the argument list, notice that find_words defines a function parameter, which captures our intent to pass to xref the function to use to split the input into words. The other interesting thing is that we say = split after the definition of find_words, which indicates that this parameter has a default argument. When we give a parameter a default argument, we're saying that callers can omit that argument if they wish. If they supply an argument, the function will use it. If they omit the argument, the compiler will substitute the default. Thus, users can call this function in either of two ways: xref(cin); // uses split to find words in the input stream xref(cin, find_urls); // uses the function named find_urls to find words The function body starts by defining a string variable, named line, which will hold each line of input as we read it, and an int variable, named line_number, to hold the line number of the line that we are currently processing. The input loop calls getline (§5.7/91) to read a line at a time into line. As long as there is input, we increment the line counter and then process each word in the line. We begin that processing by declaring a local variable named words, which will hold all the words from line, and initialize it by calling find_words. That function will be either our split function (§6.1.1/103), which splits line into its component words, or another function that takes a string argument and returns a vector<string> result. We continue with a for statement that visits each element in words, updating the map each time through words. The for header should be familiar: It defines an iterator, and marches that iterator sequentially through words. The statement that forms the body of the for may be hard to understand on first reading, ret[*it].push_back(line_number); so we'll pick it apart a bit at a time. The iterator it denotes an element of words, and so *it is one of the words in the input line. We use that word to index our map. The expression ret[*it] returns the value stored in the map at the position indexed by *it. That value is a vector<int>, which holds the line numbers on which this word has appeared so far. We call that vector's push_back member to append the current line number to the vector. As we saw in §7.2/125, if this is the first time we've seen this word, then the associated vector<int> will be value-initialized. Value-initialization of class types is a bit complicated, as we'll see in §9.5/164; what we need to know is that vectors are value-initialized the same way that variables of type vector are created when we don't give them an initial value explicitly. In both cases, the vector is created without any elements. Thus, when we insert a new string key into the map, it will be associated with an empty vector<int>. The call to push_back will append the current line number to this initially empty vector. Having written the xref function, we can use it to generate a cross-reference table: int main() { // call xref using split by default map<string, vector<int> > ret = xref(cin); // write the results for (map<string, vector<int> >::const_iterator it = ret.begin(); it != ret.end(); ++it) { // write the word cout << it->first << " occurs on line(s): "; // followed by one or more line numbers vector<int>::const_iterator line_it = it->second.begin(); cout << *line_it; // write the first line number ++line_it; // write the rest of the line numbers, if any while (line_it != it->second.end()) { cout << ", " << *line_it; ++line_it; } // write a new line to separate each word from the next cout << endl; } return 0; } We expect that this code will look as unfamiliar as the code that updated the map. Nevertheless, it uses only operations that we've already seen. We begin by calling xref to build a data structure that contains the numbers of the lines on which each word appears. We use the default value for the function parameter, so this call to xref will use split to break the input into words. The rest of the program writes the contents of the data structure that split returns. Most of the program is the for statement, the form of which should be familiar from §7.2/124. It starts at the first element in ret and looks at all the elements in sequence. As you read the body of the for loop, remember that dereferencing a map iterator yields a value of type pair. The first element of the pair holds the (const) key, and the second element is the value associated with that key. We begin the for loop by writing the word that we're processing and a message: cout << it->first << " occurs on line(s): "; That word is the key at the position in the map associated with the iterator it. We get at the key by dereferencing the iterator and fetching the first element from the pair. We are justified in writing the message at this point because the only way an element could have gotten into ret is if it represents a word with one or more references. In this case, we know for certain that at least one line number will follow the message. We don't know if there will be more than one, so we are ambiguous about the plural. Just as it->first is the key, it->second is the associated value, which in this case is a vector<int> that holds the current word's line numbers. We define line_it as an iterator that we will use to access the elements of it->second. We want commas to separate those numbers, but we don't want a stray comma at the end. Therefore, we must treat either the first or the last element specially. We choose to treat the first one specially, by writing that element explicitly. It is safe to do so because every element of ret represents a word with at least one reference to it. Having written an element, we increment the iterator to indicate that we've done so. Then the while loop iterates through the remaining elements (if any) of the vector<int>. For each element, it writes a comma, followed by the value of the element.