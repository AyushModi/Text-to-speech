operator from string, which, as we learned in §1.2/13, concatenates its arguments. To form the output line, we concatenate the right- and left-hand borders with the string that we want to display, which is stored in v[i]. The third string in our concatenation, string(maxlen - v[i].size(), ' '), constructs an unnamed, temporary string that holds the right number of blanks. We construct this string in the same way that we initialized border. We obtain the number of blanks by subtracting the size of the current string from maxlen. With this knowledge, we can see that the argument to push_back is a new string that consists of an asterisk, followed by a space, followed by the current string, followed by enough spaces to make the string as long as the longest string, followed by another space and another asterisk. All that's left is to append the bottom border and return. 5.8.2 Vertical concatenation What makes character pictures a fun example is that, once we have them, we can do things with them. We just saw one operation—framing a picture. Another operation is concatenation, which we can do both vertically and horizontally. We'll look at vertical concatenation here, and at horizontal concatenation in the next section. Pictures are naturally organized by rows, in the sense that we represent a picture by a vector<string>, each element of which is a row. Therefore, concatenating two pictures vertically is simple: We merely concatenate the vectors that represent them. Doing so will cause the two pictures to line up along their left margins, which is a reasonable way to define vertical concatenation. The only problem is that although there is a string concatenation operation, there is no vector concatenation operation. As a result, we have to do the work ourselves: vector<string> vcat(const vector<string>& top, const vector<string>& bottom) { // copy the top picture vector<string> ret = top; // copy entire bottom picture for (vector<string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it) ret.push_back(*it); return ret; } This function uses only facilities that we have already seen: We define ret as a copy of top, append each element of bottom to ret, and return ret as its result. The loop in this function implements one form of a common idea, namely, that of inserting a copy of elements from one container into another. In this particular case, we are appending the elements, which we can think of as inserting them at the end. Because this operation is so common, the library offers a way of doing it without writing a loop. Instead of for (vector<string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it) ret.push_back(*it); we can write ret.insert(ret.end(), bottom.begin(), bottom.end()); with the same effect. 5.8.3 Horizontal concatenation By horizontal concatenation, we mean taking two pictures, and making a new picture in which one of the input pictures forms the left part of the new picture, and the other forms the right part. Before we start, we need to think about what we want to do when the pictures to concatenate are different sizes. We'll arbitrarily decide that we'll align them along their top edges. Thus, each row of the output picture will be the result of concatenating the corresponding rows of the two input pictures. We'll have to pad the left-hand picture's rows to make them take up the right amount of space in the output picture. In addition to padding the left-hand picture, we also have to worry about what to do when the pictures have a different number of rows. For example, if p holds our initial picture, we might want to concatenate the original value of p horizontally with the result of framing p. That is, we'd like hcat(p, frame(p)) to produce this is an ************** example * this is an * to * to * illustrate * illustrate * framing * framing * ************** Note that the left-hand picture has fewer rows than the right-hand picture. This fact implies that we will have to pad the output on the left-hand side to account for these missing rows. If the left-hand picture is longer, we'll just copy the strings from it into the new picture; we won't bother to pad the (empty) right side with blanks. With this analysis complete, we can write our function: vector<string> hcat(const vector<string>& left, const vector<string>& right) { vector<string> ret; // add 1 to leave a space between pictures string::size_type width1 = width(left) + 1; // indices to look at elements from left and right respectively vector<string>::size_type i = 0, j = 0; // continue until we've seen all rows from both pictures while (i != left.size() || j != right.size()) { // construct new string to hold characters from both pictures string s; // copy a row from the left-hand side, if there is one if (i != left.size()) s = left[i++]; // pad to full width s += string(width1 - s.size(), ' '); // copy a row from the right-hand side, if there is one if (j != right.size()) s += right[j++]; // add s to the picture we're creating ret.push_back(s); } return ret; } We start, as we did for frame and vcat, by defining the picture that we'll return. Our next step is to compute the width to which we must pad the left-hand picture. That width will be one more than the width of the picture itself, to leave a space between the pictures when we concatenate them. Next, we iterate through both pictures, copying an element from the first, padded as necessary, followed by an element from the second. The only tricky part is taking care of what to do if we run out of elements in one picture before we run out of elements in the other. Our iteration continues until we have copied all the elements for each input vector. Hence, the while loop continues until both indices reach the end of their respective pictures. If we have not yet exhausted left, we copy its current element into s. Regardless of whether we copied anything from left, we next call the string compound assignment operator, +=, to pad the output to the appropriate width. The compound assignment operator defined by the string library operates as you might expect: It adds the right- hand operand to its left-hand operand and stores the result in the left-hand side. Of course, "add" here means string concatenation. We determine how much to pad by subtracting s.size() from width1. We know that either s.size() is the size of the string that we copied from left, or it is zero because there was no entry to copy. In the first case, s.size() will be greater than zero and less than width1, because we added one to the length of the longest string to account for a space between the two pictures. Thus, in this case, we'll append one or more blanks to s. If s.size() is zero, then we'll pad the entire output line. Having copied and padded the string for the left-hand picture, we need only append the string from the right-hand picture, assuming that there still is an element from right to copy. Regardless of whether we added a value from right, we push s onto the output vector, and continue until we've processed both input vectors— remembering to return to our caller the picture that we've created. It is important to note that the correct behavior of our program depends on the fact that s is local to the while loop. Because s is declared inside the while, it is created, with a null value, and destroyed on each trip through the loop. 5.9 Details Containers and iterators: The standard library is designed so that similar operations on different containers have the same interface and the same semantics. The containers we have used so far are all sequential containers. We'll see in Chapter 7 that the library also provides associative containers. All the sequential containers and the string type provide the following operations: container<T>::iterator container<T>::const_iterator The name of the type of the iterator on this container. container<T>::size_type The name of the appropriate type to hold the size of the largest possible instance of this container. Iterators referring to the first and (one past) the last element in the container. c.begin() c.end() c.rbegin() c.rend() Iterators referring to the last and (one beyond) the first element in the container that grant access to the container's elements in reverse order. container<T> c; container<T> c(c2); container<T> c(n); Defines c as a container that is empty or a copy of c2 if given. Defines c as a container with n elements that are value-initialized (§7.2/125) according to the type of T. If T is a class type, that type will control how to initialize the elements. If T is a built-in arithmetic type, then the elements will be initialized to 0. container<T> c(n, t); Defines c as a container with n elements that are copies of t. container<T> c(b, e); Creates a container that holds a copy of the elements denoted by iterators in the range [b, e). c = c2 Replaces the contents of container c with a copy of the container c2. Returns the number of elements in c as a size_type. c.size() c.empty() Predicate that indicates whether c has no elements. c.insert(d, b, e) Copies elements denoted by iterators in the range [b, e) and inserts them into c immediately before d. c.erase(it) c.erase(b, e) Removes the element denoted by it or the range of elements denoted by [b, e) from the container c. This operation is fast for list but can be slow for vector and string, because for these types it involves copying all the elements after the one that is removed. For list, iterators to the element(s) that are erased are invalidated. For vector and string, all iterators to elements after the one erased are invalidated. c.push_back(t) Adds an element to the end of c with the value t. Containers that support random access, and the string type, also provide the following: Fetches the character at position n from the container c. Iterator operations: Dereferences the iterator it to obtain the value stored in the container at the position that it denotes. This operation is often combined with . to obtain a member of a class object, as in (*it).x, which yields the member x of the object denoted by the iterator it. * has lower precedence than . and the same precedence as ++ and —. Equivalent to (*it).x, which returns the member x denoted by the object obtained by dereferencing the iterator it. Same precedence as the . operator. Increments the iterator so that it denotes the next element in the container. Compares two iterators for equality or inequality. The string type offers iterators that support the same operations as do iterators on c[n] *it it->x ++i it++ b == e b != e vectors. In particular, string supports full random access, about which we'll learn more in Chapter 8. In addition to the operations on containers, string also provides: s.substr(i, j) Creates a new string that holds a copy of the characters in s with indices in the range [i, i + j). getline(is, s) Reads a line of input from is and stores it in s. s += s2 Replaces the value of s by s + s2. The vector type offers the most powerful iterators, called random-access iterators, of any of the library containers. We'll learn more about these in Chapter 8. Although all the functions we've written have relied on dynamically allocating our vector elements, there are also mechanisms for preallocating elements, and an operation to direct the vector to allocate, but not to use, additional memory in order to avoid the overhead of repeated memory allocations. Reserves space to hold n elements, but does not initialize them. This operation does not change the size of the container. It affects only the frequency with which vector may have to allocate memory in response to repeated calls to insert or push_back. Gives v a new size equal to n. If n is smaller than the current size of v, elements beyond n are removed from the vector. If n is greater than the current size, then new elements are added to v and initialized as appropriate to the type in v. The list type is optimized for efficiently inserting and deleting elements at any point in the container. The operations on lists and list iterators include those described in §5.9/96. In addition, v.reserve(n) v.resize(n) l.sort() l.sort(cmp) Sorts the elements in l using the < operator for the type in the list, or the predicate cmp. The <cctype> header provides useful functions for manipulating character data: isspace(c) true if c is a whitespace character. isalpha(c) true if c is an alphabetic character. isdigit(c) true if c is a digit character. isalnum(c) true if c is a letter or a digit. ispunct(c) true if c is a punctuation character. isupper(c) true if c is an uppercase letter. islower(c) true if c is a lowercase letter. toupper(c) Yields the uppercase equivalent to c tolower(c) Yields the lowercase equivalent to c Exercises 5-0. Compile, execute, and test the programs in this chapter. 5-1. Design and implement a program to produce a permuted index. A permuted index is one in which each phrase is indexed by every word in the phrase. So, given the following input, The quick brown fox jumped over the fence the output would be The quick brown fox jumped over the fence The quick brown fox jumped over the fence jumped over the fence The quick brown fox jumped over the fence The quick brown fox A good algorithm is suggested in The AWK Programming Language by Aho, Kernighan, and Weinberger (Addison-Wesley, 1988). That solution divides the problem into three steps: 1. Read each line of the input and generate a set of rotations of that line. Each rotation puts the next word of the input in the first position and rotates the previous first word to the end of the phrase. So the output of this phase for the first line of our input would be The quick brown fox quick brown fox The brown fox The quick fox The quick brown Of course, it will be important to know where the original phrase ends and where the rotated beginning begins. Sort the rotations. Unrotate and write the permuted index, which involves finding the separator, putting the phrase back together, and writing it properly formatted. 2. 3. 3. 5-2. Write the complete new version of the student-grading program, which extracts records for failing students, using vectors. Write another that uses lists. Measure the performance difference on input files of ten lines, 1,000 lines, and 10,000 lines. 5-3. By using a typedef, we can write one version of the program that implements either a vector-based solution or a list-based one. Write and test this version of the program. 5-4. Look again at the driver functions you wrote in the previous exercise. Note that it is possible to write a driver that differs only in the declaration of the type for the data structure that holds the input file. If your vector and list test drivers differ in any other way, rewrite them so that they differ only in this declaration. 5-5. Write a function named center(const vector<string>&) that returns a picture in which all the lines of the original picture are padded out to their full width, and the padding is as evenly divided as possible between the left and right sides of the picture. What are the properties of pictures for which such a function is useful? How can you tell whether a given picture has those properties? 5-6. Rewrite the extract_fails function from §5.1.1/77 so that instead of erasing each failing student from the input vector v, it copies the records for the passing students to the beginning of v, and then uses the resize function to remove the extra elements from the end of v. How does the performance of this version compare with the one in §5.1.1/77? 5-7. Given the implementation of frame in §5.8.1/93, and the following code fragment vector<string> v; frame(v); describe what happens in this call. In particular, trace through how both the width function and the frame function operate. Now, run this code. If the results differ from your expectations, first understand why your expectations and the program differ, and then change one to match the other. 5-8. In the hcat function from §5.8.3/95, what would happen if we defined s outside the scope of the while? Rewrite and execute the program to confirm your hypothesis. 5-9. Write a program to write the lowercase words in the input followed by the uppercase words. 5-10. Palindromes are words that are spelled the same right to left as left to right. Write a program to find all the palindromes in a dictionary. Next, find the longest palindrome. 5-11. In text processing it is sometimes useful to know whether a word has any ascenders or descenders. Ascenders are the parts of lowercase letters that extend above the text line; in the English alphabet, the letters b, d, f, h, k, l, and t have ascenders. Similarly, the descenders are the parts of lowercase letters that descend below the line; In English, the letters g, j, p, q, and y have descenders. Write a program to determine whether a word has any ascenders or descenders. Extend that program to find the longest word in the dictionary that has neither ascenders nor descenders. 6 Using library algorithms As we saw in Chapter 5, many container operations apply to more than one type of container. For example, vector, string , and list allow us to insert elements by calling insert and remove elements by calling erase . These operations have the same interface for each type that supports them. For that matter, many container operations also apply to the string class. Every container—as well as the string class—provides companion iterator types, which let us navigate through a container and examine its elements. Again, the library ensures that every iterator that supplies an operation does so through the same interface. For example, we can use the ++ operator to advance any type of iterator from one element to the next; we can use the * operator to access the element associated with any type of iterator; and so on. In this chapter, we'll see how the library exploits these common interfaces to provide a collection of standard algorithms. By using these algorithms, we can avoid writing (and rewriting) the same code over and over again. More important, we can write programs that are smaller and simpler than we would write otherwise—sometimes astonishingly so. Like containers and iterators, algorithms also use consistent interface conventions. This consistency lets us learn a few of the algorithms and then apply that knowledge to others as the need arises. In this chapter, we'll use several of the library algorithms to solve problems related to processing string s and student grades. Along the way, we'll cover most of the core concepts in the algorithm library. Unless we say otherwise, the <algorithm> header defines all the algorithms that we introduce in this chapter. 6.1 Analyzing strings In §5.8.2/94, we used a loop to concatenate two character pictures: for (vector<string>::const_iterator it = bottom.begin(); it != bottom.end(); ++it) ret.push_back(*it); We noted that this loop was equivalent to inserting a copy of the elements of bottom at the end of ret , an operation that vectors provided directly: ret.insert(ret.end(), bottom.begin(), bottom.end()); This problem has an even more general solution: We can separate the notion of copying elements from that of inserting elements at the end of a container, as follows: copy(bottom.begin(), bottom.end(), back_inserter(ret)); Here, copy is an example of a generic algorithm, and back_inserter is an example of an iterator adaptor. A generic algorithm is an algorithm that is not part of any particular kind of container, but instead takes a cue from its arguments' types about how to access the data it uses. The standard library's generic algorithms usually take iterators among their arguments, which they use to manipulate the elements of the underlying containers. So, for example, the copy algorithm takes three iterators, which we'll call begin, end , and out , and copies all the elements in the range [begin, end) to a sequence of elements starting at out and extending as far as necessary. In other words, copy(begin, end, out); has the same effect as while (begin != end) *out++ = *begin++; it = begin++; is equivalent to it = begin; ++begin; except that the while body changes the values of the iterators, and copy doesn't. Before we describe iterator adaptors, we should note that this loop depends on the use of the postfix version of the increment operators. These operators differ from the prefix versions, which we have used up to now, in that begin++ returns a copy of the original value of begin , incrementing the stored value of begin as a side effect. In other words, The increment operators have the same precedence as * , and they are both right- associative, which means that *out++ has the same meaning as *(out++) . Thus, *out++ = *begin++; is equivalent to the more verbose { *out = *begin; ++out; ++begin; } Let's return to iterator adaptors , which are functions that yield iterators with properties that are related to their arguments in useful ways. The iterator adaptors are defined in <iterator> . The most common iterator adaptor is back_inserter , which takes a container as its argument and yields an iterator that, when used as a destination, appends values to the container. For example, back_inserter(ret) is an iterator that, when used as a destination, appends elements to ret . Therefore, copy(bottom.begin(), bottom.end(), back_inserter(ret)); copies all of the elements of bottom and appends them to the end of ret . After this function completes, the size of ret will have increased by bottom.size() . Notice that we could not call // error—ret is not an iterator copy(bottom.begin(), bottom.end(), ret); because copy's third argument is an iterator, not a container. Nor could we call // error - no element at ret.end() copy(bottom.begin(), bottom.end(), ret.end()); This latter mistake is particularly insidious, because the program will compile. What it does when you try to run it is another story entirely. The first thing copy will try to do is assign a value to the element at ret.end() . There's no element there, so what the implementation will do is anybody's guess. Why is copy designed this way? Because separating the notions of copying elements and expanding a container allows programmers to choose which operations to use. For example, we might want to copy elements on top of elements that already exist in a container, without changing the container's size. As another example, which we shall see in §6.2.2/112, we might want to use back_inserter to append elements to a container that are not merely copies of another container's elements. 6.1.1 Another way to split Another function that we can write more directly using the standard algorithms is split , which we saw in §5.6/88. The hard part of writing that function was dealing with the indices that delimited each word in the input line. We can replace the indices by iterators, and use standard-library algorithms to do much of the work for us: // true if the argument is whitespace, false otherwise bool space(char c) { return isspace(c); } // false if the argument is whitespace, true otherwise bool not_space(char c) { return !isspace(c); } vector<string> split(const string& str) { typedef string::const_iterator iter; vector<string> ret; iter i = str.begin(); while (i != str.end()) { // ignore leading blanks i = find_if(i, str.end(), not_space); // find end of next word iter j = find_if(i, str.end(), space); // copy the characters in [i, j) if (i != str.end()) ret.push_back(string(i, j)); i = j; } return ret; } This code uses a lot of new functions, so it will take a bit of explanation. The key idea to keep in mind is that it implements the same algorithm as the original, using i and j to delimit each word in str . Once we've found a word, we copy it from str , and push the copy onto the back of ret . This time, i and j are iterators, not indices. We use typedef to abbreviate the iterator type, so that we can use iter instead of the longer string::const_iterator . Although the string type does not support all of the container operations, it does support iterators. Therefore, we can use the standard-library algorithms on the characters of a string , just as we can use them on the elements of a vector . The algorithm that we use in this example is find_if . Its first two arguments are iterators that denote a sequence; the third is a predicate, which tests its argument and returns true or false . The find_if function calls the predicate on each element in the sequence, stopping when it finds an element for which the predicate yields true . The standard library provides an isspace function to test whether a character is a space. However, that function is overloaded, so that it will work with languages, such as Japanese, that use other character types, such as wchar_t (§1.3/14). It's not easy to pass an overloaded function directly as an argument to a template function. The trouble is that the compiler doesn't know which version of the overloaded function we mean, because we haven't supplied any arguments that the compiler might use to select a version. Accordingly, we'll write our own predicates, called space and not_space , that make clear which version of isspace we intend. The first call to find_if seeks the first nonspace character, which begins a word. Remember that one or more spaces might begin a line or might separate adjacent words in the input. We don't want to include these spaces in the output. After the first call to find_if , i will denote the first nonspace, if any, in str . We use i in the next call to find_if , which looks for the first space in [i, str.end()) . If find_if fails to find a value that satisfies the predicate, it returns its second argument, which, in this case, is str.end() . Therefore, j will be initialized to denote the blank that separates the next word in str from the rest of the line, or, if we are on the last word in the line, j will be equal to str.end() . At this point, i and j delimit a word in str . All that's left is to use these iterators to copy the data from str into ret . In the earlier version of split , we used string::substr to create the copy. However, that version of split operated on indices, not iterators, and there isn't a version of substr that operates on iterators. Instead, we construct a new string directly from the iterators that we have. We do so by using an expression, string(i, j) , that is somewhat similar to the definition of spaces that we explained in §1.2/13. Our present example constructs a string that is a copy of the characters in the range [i, j) . We push this new string onto the back of ret . It is worth pointing out that this version of the program omits the tests of the index i against str.size() . Nor are there the obvious equivalent tests of the iterator against str.end() . The reason is that the library algorithms are written to handle gracefully calls that pass an empty range. For example, at some point the first call to find_if will set i to the value returned by str.end() , but there is no need to check i before passing it to the second call to find_if . The reason is that find_if will look in the empty range [i, str.end()) and will return str.end() to indicate that there is no match. 6.1.2 Palindromes Another character-manipulation problem that we can use the library to solve succinctly is determining whether a word is a palindrome. Palindromes are words that are spelled the same way front to back as back to front. For example, "civic," "eye," "level," "madam," and "rotor" are all palindromes. Here is a compact solution that uses the library: bool is_palindrome(const string& s) { return equal(s.begin(), s.end(), s.rbegin()); } The return statement in this function's body calls the equal function and the rbegin member function, both of which we have not yet seen. Like begin , rbegin returns an iterator, but this time it is an iterator that starts with the last element in the container and marches backward through the container. The equal function compares two sequences to determine whether they contain equal values. As usual, the first two iterators passed to equal specify the first sequence. The third argument is the starting point for the second sequence. The equal function assumes that the second sequence is the same size as the first, so it does not need an ending iterator. Because we pass s.rbegin() as the starting point for the second sequence, the effect of this call is to compare values from the back of s to values in the front. The equal function will compare the first character in s with the last. Then it will compare the second to the next to last, and so on. This behavior is precisely what we want. 6.1.3 Finding URLs As the last of our examples of character manipulation, let's write a function that finds Web addresses, called uniform resource locators (URLs), that are embedded in a string . We might use such a function by creating a single string that holds the entire contents of a document. The function would then scan the document and find all the URLs in it. A URL is a sequence of characters of the form protocol-name: //resource-name where protocol-name contains only letters, and resource-name may consist of letters, digits, and certain punctuation characters. Our function will take a string argument and will look for instances of :// in that string . Each time we find such an instance, we'll look for the protocol-name that precedes it, and the resource-name that follows it. Because we want our function to find all the URLs in its input, we'll want it to return a vector<string> , with one element for each URL. The function executes by moving the iterator b through the string , looking for the characters :// that might be a part of a URL. If we find these characters, it looks backward to find the protocol-name, and it looks forward to find the resource-name: vector<string> find_urls(const string& s) { vector<string> ret; typedef string::const_iterator iter; iter b = s.begin(), e = s.end(); // look through the entire input while (b != e) { // look for one or more letters followed by :// b = url_beg(b, e); // if we found it if (b != e) { // get the rest of the URL iter after = url_end(b, e); // remember the URL ret.push_back(string(b, after)); // advance b and check for more URLs on this line b = after; } } return ret; } We start by declaring ret , which is the vector into which we will put the URLs as we find them, and by obtaining iterators that delimit the string . We will have to write the url_beg and url_end functions, which will find the beginning and end of any URL in the input. The url_beg function will be responsible for identifying whether a valid URL is present and, if so, for returning an iterator that refers to the first character of the protocol- name. If it does not identify a URL in the input, then it will return its second argument (e in this case) to indicate failure. If url_beg finds a URL, the next task is to find the end of the URL by calling url_end . That function will search from the given position until it reaches either the end of the input or a character that cannot be part of a URL. It will return an iterator positioned one past the last character in the URL. Thus, after the calls to url_beg and url_end , the iterator b denotes the beginning of a URL, and the iterator after denotes the position one past the last character in the URL: We construct a new string from the characters in this range, and push that string onto the back of ret . All that remains is to increment the value of b and to look for the next URL. Because URLs cannot overlap one another, we set b to (one past) the end of the URL that we just found, and continue the while loop until we've looked at all the input. Once that loop exits, we return the vector that contains the URLs to our caller. Now we have to think about url_beg and url_end . The url_end function is simpler, so we'll start there: string::const_iterator url_end(string::const_iterator b, string::const_iterator e) { return find_if(b, e, not_url_char); } This function just forwards its work to the library find_if function, which we used in §6.1.1/103. The predicate that we pass to find_if is one that we will write, named not_url_char . It will return true when passed a character that cannot be in a URL: bool not_url_char(char c) { // characters, in addition to alphanumerics, that can appear in a URL static const string url_ch = "~;/?:@=&$-_.+!*'(),"; // see whether c can appear in a URL and return the negative return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end()); } Despite being small, this function uses a fair bit of new material. First is the use of the static storage class specifier . Local variables that are declared to be static are preserved across invocations of the function. Thus, we will create and initialize the string url_ch only on the first call to not_url_char . Subsequent calls will use the object that the first call created. Because url_ch is a const string , its value will not change once we have initialized it. The not_url_char function also uses the isalnum function, which the <cctype> header defines. This function tests whether its argument is an alphanumeric character (a letter or a digit). Finally, find is another algorithm that we haven't used yet. It is similar to find_if , except that instead of calling a predicate, it looks for the specific value given as its third argument. As with find_if , if the value that we want is present, the function returns an iterator denoting the first occurrence of the value in the given sequence. If the value is not found, then find returns its second argument. With this information in hand, we can now understand the not_url_char function. Because we negate the value of the entire expression before we return it, not_url_char will yield false if c is a letter, a digit, or any of the characters in url_ch . If c is any other value, the function returns true . Now the hard part begins: implementing url_beg . This function is messy, because it must deal with the possibility that the input might contain :// in a context that cannot be a valid URL. In practice, we'd probably have a list of acceptable protocol-names and look only for those. For simplicity, though, we'll limit ourselves to being sure that one or more letters precede the :// separator, and at least one character follows it: string::const_iterator url_beg(string::const_iterator b, string::const_iterator e) { static const string sep = "://"; typedef string::const_iterator iter; // i marks where the separator was found iter i = b; while ((i = search(i, e, sep.begin(), sep.end())) != e) { // make sure the separator isn't at the beginning or end of the line if (i != b && i + sep.size() != e) { // beg marks the beginning of the protocol-name iter beg = i; while (beg != b && isalpha(beg[-1])) --beg; // is there at least one appropriate character before and after the separator? if (beg != i && !not_url_char(i[sep.size()])) return beg; } // the separator we found wasn't part of a URL advance i past this separator i += sep.size(); } return e; } The easy part is to write the function header. We know that we'll be passed two iterators denoting the range in which to look, and that we'll return an iterator that denotes the beginning of the first URL in that range, if one exists. We also declare and initialize a local string , which will hold the characters that make up the separator that identifies a potential URL. Like url_ch in the not_url_char function (§6.1.3/107), this string is static and const . Thus, we will not be able to change the string , and its value will be created only on the first invocation of url_beg . The function executes by placing two iterators into the string delimited by b and e : The iterator i will denote the beginning of the URL separator, if any, and beg will indicate the beginning of the protocol-name , if any. The function first looks for the separator, by calling search , a library function that we haven't used before. This function takes two pairs of iterators: The first pair denotes the sequence in which we are looking, and the second pair denotes the sequence that we wish to locate. As with other library functions, if search fails, it returns the second iterator. Therefore, after the call to search , either i denotes (one past) the end of the input string , or it denotes a : that is followed by //. If we found a separator, the next task is to get the letters (if any) that make up the protocol-name. We first check whether the separator is at the beginning or end of the input. If the separator is in either of those places, we know that we don't have a URL, because a URL has at least one character on each side of its separator. Otherwise, we need to try to position the iterator beg . The inner while loop moves beg backward through the input until it hits either a nonalphabetic character or the beginning of the string . It uses two new ideas: The first is the notion that if a container supports indexing, so do its iterators. In other words, beg[-1] is the character at the position immediately before the one that beg denotes. We can think of beg[-l] as an abbreviation for *(beg - 1) . We'll learn more about such iterators in §8.2.6/148. The second new idea is the isalpha function, defined in <cctype> , which tests whether its argument is a letter. If we were able to advance the iterator over as much as a single character, we assume that we've found a protocol-name. Before returning beg , we still have to check that there's at least one valid character following the separator. This test is more complicated. We know that there is at least one more character in the input, because we're inside the body of an